= Lecture Notes 22/23 - 4bhitm - SEW
:icons: font
:toc: left
ifndef::imagesdir[:imagesdir: images]

== 2022-09-26 REST
Beitrag: Peter Klose & Thomas Spindler

=== Grundproblem

Wir haben mehrere verschiedene Computer, die alle mit unterschiedlicher Hard- und Software arbeiten. Damit diese problemlos miteinander kommunizieren können, gibt es Protokolle. REST ist eines der vielen verschiedenen Protokollen, die dieses Problem lösen.

image::2022-09-26-rest-architecture.png[]

=== REST

IMPORTANT: "HTML ist das Internet der Menschen, Rest ist das Internet für Maschinen"

Rest wir verwendet, um Daten zwischen zwei Systemen auszutauschen. Hierbei verwendet man die typische Client- / Serverkonfiguration

Der Client holt sich die Informationen, die dieser Benötigt vom Server, oder sagt dem Server, dass er Informationen löschen oder speichern soll.

==== Methoden von REST [[rest_methoden]]

Rest hat verschiedene Methoden, die sich an CRUD orientieren. +

TIP: CRUD = **C**reate, **R**ead, **U**pdate, **D**elete

* POST (erstellen und speichern)
* GET (lesen)
* POST (speichern)
* PUT (update gesamte Ressource)
* PATCH (nur einzelne Felder ändern)
* DELETE (löschen)

Es gibt noch weitere Methoden, wie z.B OPTIONS.

==== URL

Um die richtigen Resource vom Server zu bekommen, wird eine URL verwendet.

TIP: URL  = Unified Resource Locator

Wie der Name schon sagt, dient eine URL dazu, dass sie den Pfad der Resource angibt. Dies ist vergleichbar mit Dateipfaden.

.Beispiele für URLs
[%collapsible]
====

Schema einer URL:

----
URI = scheme ":" ["//" authority] path ["?" query] ["#" fragment]

authority = [userinfo "@"] host [":" port]
----

Beispiele:

----
https://www.example.com/index.html

https://www.example.com/person?vname="hans"&nname="muster"
----

Beim zweitem Beispiel werden 2 weitere Parameter mitgegeben. +
nname = hans +
vname = muster +
Diese sind einfache Variablen mit Werten.

====

==== JSON

REST verwendet als unterliegendes Protokoll HTTP. Die Daten an sich werden allerdings im JSON format transportiert.

Früher wurde oft XML für den Datentransfer verwendet (vor REST). XML hat allerdings einige Nachteile gegenüber dem neueren JSON. Aus diesem Grund verwendet REST JSON.

.XML vs JSON
[%collapsible]
====

[cols="a,a", frame=none, grid=none]
|===
| XML
[source, xml]
----
<?xml version="1.0" encoding="UTF-8" ?>
<schueler>
    <vorname>Max</vorname>
    <nachname>Muster</nachname>
    <geburtsdatum>05.07.2002</geburtsdatum>
    <klasse>4BHITM</klasse>
</schueler>
----

Zeichen: **187**


| JSON
[source, json]
----
{
  "schueler": {
    "vorname": "Max",
    "nachname": "Muster",
    "geburtsdatum": "05.07.2022",
    "klasse": "4BHITM"
  }
}
----

Zeichen: **121**
|===

JSON ist hier effizienter, da es weniger Zeichen als XML hat.

Ebenfalls ist JSON meistens einfacher zu lesen als XML.

====

==== Endpoint

Ein Endpoint ist eine Schnittstelle für die Daten.

Jeder Endpoint hat eine URL und eine Methode, die dieser verwendet.

image::2022-09-26-rest-examples.png[]

==== Server Architektur

Auf dem Server werden die Anfragen entgegengenommen und verarbeitet. Hierbei kann der Server weitere Verbindungen aufbauen (Datenbank, weitere REST requests, ..), oder Berechnungen durchführen.

Dieser ist mit folgender Architektur aufgebaut:

image::2022-09-26-server-logic.png[]

Bei klassischen Anwendungen, (die wir vor allem in den letzten Jahren programmiert haben, hatte sich die Anwendung direkt mit der Datenbank verbunden. Dies ist allerdings aus Sicherheitsgründen schlecht. Ebenfalls sind Webapps einfacher, moderner und vernünftiger als z.B. Java FX.

Daher ist es ebenfalls besonders wichtig, die Daten, die der Client mit einem POST request übermittelt, am Server zu überprüfen, bevor diese gespeichert werden

== 2022-10-03 REST, REST in Quarkus
Beitrag: Peter Klose & Thomas Spindler

=== Rest

Rest ist *Zustandslos*, das heißt, dass es grundsätzlich keine Sessions gibt. Dies bedeutet aber auch, dass Anmeldeinformationen, oder weitere Tokens und Cookies bei jeder Anfrage erneut gesendet werden müssen.

==== Rest Request

Ein Rest-Request ist, wenn der Client etwas vom Server anfordert. Dies muss den <<rest_methoden, REST Methoden>> entsprechen.

===== Beispiel GET

image::2022-10-03-rest-request.png[]

===== Beispiel POST

image::2022-10-03-rest-post-request.png[]

==== Rest Begriffe

[cols="a,a", frame=none, grid=none]
|===
|
* Safety: Daten werden nicht verändert
* Idempotence: Die Ressource behält auch nach mehrmaligen Aufruf den gleichen Zustand


| image::2022-10-03-rest-begriffe.png[]

|===

=== RestfullAPI

* JSON-B
* JSON-P
* application.properties
* dev-console

=== JPA

* Persistence
** dauerhaft speichern
** die Daten überleben den Prozess, der sie erstellt hat.
** Bsp: File, DB, ev. Serialisierung (ist auch File)
* transient
** flüchtig
** die Daten werden mit dem Prozess, der sie erstellt hat, gelöscht
** zB Variablen im Programm



==== Quarkus Profiles

* Quarkus hat per default drei Profile:
. dev
. prod
. test

* Die Profile haben den Vorteil verschiedene Konfigurationen bei unterschiedlichen Anwendungsfällen zur Verfügung zu stellen. Z.B. wird eine eigene Datenbank zum Testen verwendet
* Man erkennt das jeweilige Profil in der `application.properties` durch den Prefix %prod, %test, %dev

* dev
** ist development modus
** automatisches Hot Reloading, wenn Code geändert wird
* test
** wird zum Testen verwendet
** meist wird eine eigene Testdatenbank gestartet
* prod
** Ist optimierter (z.B. startet schneller)
** hat dafür keine dev-Console, keinen Swagger (nicht automatisch) usw.


==== Was muss man tun, um eine Entity-Klasse zu persistieren?

===== Dependencies in pom.xml eintragen

* JDBC-Treiber der Datenbank
* der OR-Mapper (Object Relational Mapper, ORM)
** in Quarkus wird standardmäßig *Hibernate* verwendet.


===== DB-Credentials in application.properties eintragen

[source,properties]
----
quarkus.datasource.username=postgres
quarkus.datasource.password=postgres
quarkus.datasource.db-kind=postgresql
quarkus.hibernate-orm.database.generation=drop-and-create
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/db
----

===== Datenbank starten

[source,shell]
----
docker run --rm=true \
           --name postgres-payment \
           -e POSTGRES_USER=postgres \
           -e POSTGRES_PASSWORD=postgres \
           -e POSTGRES_DB=db \
           -v ${PWD}/db-postgres/db:/var/lib/postgresql/data \
           -p 5432:5432 \
           postgres:13.3-alpine
----

===== Erstellen einer Entity-Klasse




[source,java]
----
@Entity // <.>
@Table(name = "MY_PERSON")
public class Person {

    @Id // <.>
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // <.>
    @Column(name = "P_ID")
    private Long id;

    @Column(name = "P_FIRST_NAME")
    private String firstName;

    @Column(name="P_LAST_NAME")
    private String lastName;

    // constructors omitted for brevity

    // getter and setter omitted for brevity
}
----

<.> Annotation @Entity wird benötigt
<.> Eine Id wird benötigt -> @Id
<.> Hier wird ein Autowert-Feld in der DB erstellt
<.>


===== Zugriff auf die DB über den Entity Manager

.Injizieren des EntityManagers
[source,java]
----
@Inject
EntityManager em;
----


===== Verwenden einer Transaktion für schreibende Zugriffe

* Lesende Zugriffe benötigen keine Transaktion

[source,java]
----
@Transactional
void foo() {

    // Speichern in DB
    em.persist(new Person("Mickey", "Mouse"));

    // Holen aus DB
    Person p = em.find(Person.class, 1L);
    System.out.println(p.getFirstName());
}
----



== 2022-10-17 Tabellenbeziehungen in JPA


